< 정리 >

* 최대공약수
public static int gcd(int a, int b) {
	while(b != 0) {
		int temp = a % b;
		a = b;
		b = temp;			
	}
	return a;
}

* 최소공배수
lcm = a * b / gcd(a, b)


* 홀수 개수 구하는 공식
int size = (n + 1) / 2;

* 짝수 개수 구하는 공식
int size = n / 2;

* k개씩 나눌 때 필요한 묶음 수
int bundle = (n + k - 1) / k;

* 코테 Rule
1. 숫자가 2번 이상 나오면 무조건 상수로 빼기
2. 숫자가 1번만 나오고, 문제에서 기준이 너무 명확하면 그냥 써도 OK
3. ‘의미’를 이름으로 보여주고 싶으면 1번이어도 상수로 빼기
4. 입력값(매개변수)은 상수로 만들지 말기
예: YEAR, PRICE, LIMIT 같은 이름이 의미를 살릴 때
5. 부동소수점(0.8 같은 거) 나오면 가능하면 정수 연산으로 바꾸기
예: price * 80 / 100 처럼

* 문자 만들기
StringBuilder을 사용하는게 용량을 축소 시킬 수 있음
예: StringBuilder sb = new StringBuilder(my_string.length());
그냥 뒤집기만이면 : reverse()
규칙/조건이 섞이면 : 직접 append

* 문자 반복 시
StringBuilder append 또는 String repeat


< 오답노트 >

Basic ------------------------------------------

: 복습 필요 문제
- Q7
- Q11
- Q12
- Q13
- Q18
_ Q21
_ Q22

: 실패 후 성공 문제
- Q17







